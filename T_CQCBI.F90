PROGRAM cqcbi

! Code converted using TO_F90 by Alan Miller
! Date: 2002-02-08  Time: 17:53:30

!***DATE WRITTEN   830501   (YYMMDD)
!***REVISION DATE  890801, 930101   (YYMMDD)

!     CQCBI IS A QUICK CHECK ROUTINE FOR THE COMPLEX I BESSEL FUNCTION
!     GENERATED BY SUBROUTINE CBESI.

!     CQCBK GENERATES SEQUENCES OF I AND K BESSEL FUNCTIONS FROM
!     CBESI AND CBESK AND CHECKS THE WRONSKIAN EVALUATION

!           I(FNU,Z)*K(FNU+1,Z) + I(FNU+1,Z)*K(FNU,Z) = 1/Z

!     IN THE RIGHT HALF PLANE AND A MODIFIED FORM

!          I(FNU+1,Z)*K(FNU,ZR) - I(FNU,Z)*K(FNU+1,ZR) = C/Z

!     IN THE LEFT HALF PLANE WHERE ZR=-Z AND C=EXP(I*FNU*SGN) WITH
!     SGN=+1 FOR IM(Z) >= 0 AND SGN=-1 FOR IM(Z) < 0.

!     THE PARAMETER MQC CAN HAVE VALUES 1 (THE DEFAULT) FOR A FASTER,
!     LESS DEFINITIVE TEST OR 2 FOR A SLOWER, MORE DEFINITIVE TEST.

!     MACHINE CONSTANTS ARE DEFINED IN FUNCTIONS I1MACH, R1MACH, AND
!     D1MACH.  THESE MUST BE SELECTED BY THE USER OR SET ACCORDING TO
!     PROLOGUE INSTRUCTIONS.

USE Complex_Bessel
IMPLICIT NONE

COMPLEX (dp)  :: cone, csgn, cc, cv, cw, cy, w(20), y(20), z, zr
REAL (dp)     :: aa, ab, aer(20), alim, arg, atol, dig, elim, eps, er, ertol, &
                 ffnu, fnu, fnul, gnu, hpi, pi, r, rl, r1m4, r1m5, r2, rm, &
                 t(20), tol, xx, yy, slak, ts, st, ct, film, xnu(20)
INTEGER       :: i, icase, ifnu, il, iprnt, ir, it, itl, irb, k, kk, kode,  &
                 k1, k2, lflg, mflg, n, nu, nz, n1, nul, ierr, nl, keps(20), &
                 kdo(20)
INTEGER, PARAMETER :: mqc = 1, lun = 7
OPEN (lun, FILE='CQCBI.OUT')
!-----------------------------------------------------------------------
!     SET PARAMETERS RELATED TO MACHINE CONSTANTS.
!     TOL IS THE APPROXIMATE UNIT ROUNDOFF LIMITED TO 1.0E-18.
!     ELIM IS THE APPROXIMATE EXPONENTIAL OVER- AND UNDERFLOW LIMIT.
!     EXP(-ELIM) < EXP(-ALIM)=EXP(-ELIM)/TOL    AND
!     EXP(ELIM) > EXP(ALIM)=EXP(ELIM)*TOL       ARE INTERVALS NEAR
!     UNDERFLOW AND OVERFLOW LIMITS WHERE SCALED ARITHMETIC IS DONE.
!     RL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC EXPANSION FOR LARGE Z.
!     DIG = NUMBER OF BASE 10 DIGITS IN TOL = 10**(-DIG).
!     FNUL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC SERIES FOR LARGE FNU
!-----------------------------------------------------------------------
r1m4 = EPSILON(0.0_dp)
tol = MAX(r1m4, 1.0D-18)
aa = -LOG10(r1m4)
k1 = MINEXPONENT(0.0_dp)
k2 = MAXEXPONENT(0.0_dp)
r1m5 = LOG10( REAL(RADIX(0.0_dp), KIND=dp) )
k = MIN(ABS(k1), ABS(k2))
elim = 2.303_dp * (k*r1m5 - 3.0_dp)
ab = aa * 2.303_dp
alim = elim + MAX(-ab, -41.45_dp)
dig = MIN(aa,18.0_dp)
fnul = 10.0_dp + 6.0_dp * (dig - 3)
rl = 1.2_dp * dig + 3.0_dp
slak = 3.0_dp + 4.0_dp * (-LOG10(tol) - 7.0_dp) / 11.0_dp
slak = MAX(slak,3.0_dp)
ertol = tol * 10.0_dp ** slak
rm = 0.5_dp * (alim+elim)
rm = MIN(rm, 200.0_dp)
rm = MAX(rm, rl+10.0_dp)
r2 = MIN(fnul, rm)
!-----------------------------------------------------------------------
WRITE (lun,5000)
WRITE (lun,5100)
WRITE (lun,5200) tol, elim, alim, rl, fnul, dig
cone = CMPLX(1.0_dp, 0.0_dp, KIND=dp)
atol = 100.0_dp * tol
hpi = 2.0_dp * ATAN(1.0_dp)
pi = hpi + hpi
WRITE (lun,5300) mqc
!-----------------------------------------------------------------------
!     TEST VALUES OF Z IN -PI < ARG(Z) <= PI NEAR FORMULA BOUNDARIES
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!     KDO(K), K=1,IL  DETERMINES WHICH OF THE IL ANGLES IN -PI TO PI
!     ARE USE TO COMPUTE VALUES OF Z
!       KDO(K) = 0  MEANS THAT THE INDEX K WILL BE USED FOR ONE OR TWO
!                   VALUES OF Z, DEPENDING ON THE CHOICE OF KEPS(K)
!              = 1  MEANS THAT THE INDEX K AND THE CORRESPONDING ANGLE
!                   WILL BE SKIPPED
!     KEPS(K), K=1,IL DETERMINES WHICH OF THE ANGLES GET INCREMENTED
!     UP AND DOWN TO PUT VALUES OF Z IN REGIONS WHERE DIFFERENT
!     FORMULAE ARE USED.
!       KEPS(K) =0  MEANS THAT THE ANGLE WILL BE USED WITHOUT CHANGE
!               =1  MEANS THAT THE ANGLE WILL BE INCREMENTED UP AND
!                   DOWN BY EPS
!     THE ANGLES TO BE USED ARE STORED IN THE T(I) ARRAY, I=1,ITL
!-----------------------------------------------------------------------
IF (mqc /= 2) THEN
  nl = 2
  il = 5
  DO  i = 1, il
    keps(i) = 0
    kdo(i) = 0
  END DO
  nul = 5
  xnu(1) = 0.0_dp
  xnu(2) = 1.0_dp
  xnu(3) = 2.0_dp
  xnu(4) = 0.5_dp * fnul
  xnu(5) = fnul + 1.1_dp
ELSE
  nl = 4
  il = 13
  DO  i = 1, il
    kdo(i) = 0
    keps(i) = 0
  END DO
  kdo(2) = 1
  kdo(6) = 1
  kdo(8) = 1
  kdo(12) = 1
  keps(3) = 1
  keps(4) = 1
  keps(5) = 1
  keps(9) = 1
  keps(10) = 1
  keps(11) = 1
  nul = 6
  xnu(1) = 0.0_dp
  xnu(2) = 0.6_dp
  xnu(3) = 1.3_dp
  xnu(4) = 2.0_dp
  xnu(5) = 0.5_dp * fnul
  xnu(6) = fnul + 1.1_dp
END IF
i = 2
eps = 0.01_dp
film = (il-1)
t(1) = -pi + eps
DO  k = 2, il
  IF (kdo(k) == 0) THEN
    t(i) = pi * (-il+2*k-1) / film
    IF (keps(k) /= 0) THEN
      ts = t(i)
      t(i) = ts - eps
      i = i + 1
      t(i) = ts + eps
    END IF
    i = i + 1
  END IF
END DO
itl = i - 1
lflg = 0
DO  kode = 1, 2
  DO  n = 1, nl
    n1 = n + 1
    DO  nu = 1, nul
      fnu = xnu(nu)
      ifnu = INT(fnu)
      ffnu = fnu - (ifnu)
      arg = pi * ffnu
      csgn = CMPLX(COS(arg), SIN(arg), KIND=dp)
      IF (MOD(ifnu,2) == 1) csgn = -csgn
      loop110:  DO  icase = 1, 3
        irb = MIN(2,icase)
        DO  ir = irb, 4
          SELECT CASE ( icase )
            CASE (    1)
              r = (0.2_dp*(4-ir) + 2*(ir-1)) / 3.0_dp
            CASE (    2)
              r = (2*(4-ir) + r2*(ir-1)) / 3.0_dp
            CASE (    3)
              IF (r2 >= rm) CYCLE loop110
              r = (r2*(4-ir) + rm*(ir-1)) / 3.0_dp
          END SELECT

          DO  it = 1, itl
            ct = COS(t(it))
            st = SIN(t(it))
            IF (ABS(ct) < atol) ct = 0.0_dp
            IF (ABS(st) < atol) st = 0.0_dp
            xx = r * ct
            yy = r * st
            z = CMPLX(xx, yy, KIND=dp)
            IF (ct >= 0.0_dp) THEN
!-----------------------------------------------------------------------
!     WRONSKIAN CHECKS IN THE RIGHT HALF PLANE
!-----------------------------------------------------------------------
              CALL cbesi(z, fnu, kode, n1, y, nz, ierr)
              IF (nz /= 0 .OR. ierr /= 0) CYCLE
              CALL cbesk(z, fnu, kode, n1, w, nz, ierr)
              IF (nz /= 0 .OR. ierr /= 0) CYCLE
!-----------------------------------------------------------------------
!     ADJUSTMENTS TO WRONSKIAN DUE TO SCALING OF I AND K FUNCTIONS
!     ON KODE=2
!-----------------------------------------------------------------------
              cv = cone / z
              IF (kode == 2) THEN
                cw = CMPLX(COS(yy), SIN(yy), KIND=dp)
                cv = cw * cv
              END IF
              cc = cone
            ELSE
!-----------------------------------------------------------------------
!     WRONSKIAN CHECKS IN THE LEFT HALF PLANE
!-----------------------------------------------------------------------
              zr = -z
              CALL cbesi(z, fnu, kode, n1, y, nz, ierr)
              IF (nz /= 0 .OR. ierr /= 0) CYCLE
              CALL cbesk(zr, fnu, kode, n1, w, nz, ierr)
              IF (nz /= 0 .OR. ierr /= 0) CYCLE
              cv = csgn
              IF (yy < 0.0_dp) THEN
                cv = CONJG(cv)
              END IF
              cv = cv / z
              IF (kode == 2) THEN
!-----------------------------------------------------------------------
!     ADJUSTMENTS TO WRONSKIAN DUE TO SCALING OF I AND K FUNCTIONS
!     ON KODE=2. SCALE FACTOR = EXP(-I*YY) FOR RE(Z) < 0
!-----------------------------------------------------------------------
                cw = CMPLX(COS(yy), -SIN(yy), KIND=dp)
                cv = cv * cw
              END IF
              cc = -cone
            END IF
            mflg = 0
            kk = 0
            DO  i = 1, n
              cw = w(i) * y(i+1)
              cy = cc * w(i+1) * y(i)
              cy = cy + cw - cv
              er = ABS(cy) / ABS(cv)
              aer(i) = er
              IF (er > ertol) THEN
                IF (kk == 0) THEN
                  mflg = 1
                  kk = i
                END IF
              END IF
              IF (ct < 0.0_dp) cv = -cv
            END DO
            IF (mflg /= 0) THEN
              IF (lflg /= 1) THEN
                WRITE (lun,5400) ertol
                WRITE (lun,5500)
                WRITE (lun,5600)
                lflg = 1
              END IF
              WRITE (lun,5700) kode, n, ir, it, icase, kk
              WRITE (lun,5800) aer(1:n)
              WRITE (lun,5800) z, fnu, y(kk)
            END IF
          END DO
        END DO
      END DO loop110
    END DO
  END DO
END DO
IF (lflg == 0) WRITE (lun,5900)
IF (mqc == 1) STOP
!-----------------------------------------------------------------------
!     CHECKS NEAR UNDERFLOW LIMITS ON SERIES(I=1) AND UNIFORM
!     ASYMPTOTIC EXPANSION(I=2)
!-----------------------------------------------------------------------
WRITE (lun,6000)
z = CMPLX(1.4_dp, 1.4_dp, KIND=dp)
iprnt = 0
DO  i = 1, 2
  fnu = 10.2_dp
  kode = 1
  n = 20

  150 CALL cbesi(z, fnu, kode, n, y, nz, ierr)
  IF (nz == 0) THEN
    fnu = fnu + 5.0_dp
    GO TO 150
  END IF
  IF (nz >= 10) THEN
    fnu = fnu - 1.0_dp
    GO TO 150
  END IF
  CALL cbesk(z, fnu, kode, 2, w, nz, ierr)
  cv = cone / z
  cy = w(1) * y(2)
  cw = w(2) * y(1)
  cw = cw + cy - cv
  er = ABS(cw) / ABS(cv)
  IF (er >= ertol) THEN
    IF (iprnt /= 1) THEN
      WRITE (lun,6100)
      iprnt = 1
    END IF
    WRITE (lun,6200) er, z, fnu, kode, n
  END IF
  xx = rl + rl
  z = CMPLX(xx, 0.0_dp, KIND=dp)
END DO
!-----------------------------------------------------------------------
!     CHECK NEAR OVERFLOW LIMITS
!-----------------------------------------------------------------------
z = CMPLX(elim, 0.0_dp, KIND=dp)
fnu = 0.0_dp

170 CALL cbesk(z, fnu, kode, n, y, nz, ierr)
IF (nz >= 10) THEN
  IF (nz == n) fnu = fnu + 3.0_dp
  fnu = fnu + 2.0_dp
  GO TO 170
END IF
gnu = fnu + (n-2)
CALL cbesi(z, gnu, kode, 2, w, nz, ierr)
cv = cone / z
cy = y(n-1) * w(2)
cw = y(n) * w(1)
cw = cw + cy - cv
er = ABS(cw) / ABS(cv)
IF (er >= ertol) THEN
  IF (iprnt /= 1) THEN
    WRITE (lun,6100)
    iprnt = 1
  END IF
  WRITE (lun,6200) er, z, fnu, kode, n
END IF
IF (iprnt == 0) WRITE (lun,5900)
STOP

5000 FORMAT (' QUICK CHECK ROUTINE FOR THE I BESSEL FUNCTION FROM CBESI'/)
5100 FORMAT (' PARAMETERS TOL,ELIM,ALIM,RL,FNUL,DIG')
5200 FORMAT (6E12.4/)
5300 FORMAT (/' CHECKS IN THE (Z,FNU) SPACE WITH MQC = ',i2/)
5400 FORMAT (/ ' CASES WHICH VIOLATE THE RELATIVE ERROR TEST WITH ERTOL =',  &
             e12.4/)
5500 FORMAT (/' OUTPUT FORMAT'/' KODE,N,IR,IT,ICASE,KK')
5600 FORMAT (' ER(K),K=1,N'/  &
             ' Z,FNU,Y(KK)        KK=INDEX OF FIRST NON-ZERO PAIR'/)
5700 FORMAT (6I5)
5800 FORMAT (6E12.4)
5900 FORMAT (/' QUICK CHECKS OK'/)
6000 FORMAT (/' CHECKS NEAR UNDERFLOW AND OVERFLOW LIMITS'/)
6100 FORMAT (/' OUTPUT FORMAT'/' ERROR,Z,FNU,KODE,N'/)
6200 FORMAT (4E12.4,2I5)
END PROGRAM cqcbi
