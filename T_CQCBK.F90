PROGRAM cqcbk

! Code converted using TO_F90 by Alan Miller
! Date: 2002-02-08  Time: 17:53:50

!***DATE WRITTEN   830501   (YYMMDD)
!***REVISION DATE  890801, 930101   (YYMMDD)

!     CQCBK IS A QUICK CHECK ROUTINE FOR THE COMPLEX K BESSEL FUNCTION
!     GENERATED BY SUBROUTINE CBESK.

!     CQCBK GENERATES SEQUENCES OF I AND K BESSEL FUNCTIONS FROM
!     CBESI AND CBESK AND CHECKS THEM AGAINST THE WRONSKIAN EVALUATION

!           I(FNU,Z)*K(FNU+1,Z) + I(FNU+1,Z)*K(FNU,Z) = 1/Z

!     IN THE RIGHT HALF PLANE AND THE ANALYTIC CONTINUATION FORMULA
!     FOR H(FNU,2,Z) IN TERMS OF THE K FUNCTION

!           K(FNU,Z) = C3*H(FNU,2,ZR) + C4*H(FNU,1,ZR)    IM(Z).GE.0

!                    = CONJG(K(FNU,CONJG(Z)))             IM(Z).LT.0

!     IN THE LEFT HALF PLANE WHERE C3=C1*CONJG(C2)*C5, C4 = C2*C5
!     C1=2*COS(PI*FNU),   C2=EXP(PI*FNU*I/2),   C5 =-PI*I/2   AND
!     ZR = Z*EXP(-3*PI*I/2) = Z*I

!     THE PARAMETER MQC CAN HAVE VALUES 1 (THE DEFAULT) FOR A FASTER,
!     LESS DEFINITIVE TEST OR 2 FOR A SLOWER, MORE DEFINITIVE TEST.

!     MACHINE CONSTANTS ARE DEFINED IN FUNCTIONS I1MACH, R1MACH, AND
!     D1MACH. THESE MUST BE SELECTED BY THE USER OR SET ACCORDING TO
!     PROLOGUE INSTRUCTIONS.

USE Complex_Bessel
IMPLICIT NONE

COMPLEX (dp)  :: cone, csgn, cv, cw, cy, c1, c2, c3, c4, v(20), w(20),  &
                 y(20), z, zr, zz, coe
REAL (dp)     :: aa, ab, aer(20), alim, arg, atol, dig, elim, eps, er,  &
                 ertol, ffnu, fnu, fnul, hpi, pi, r, rl, rm, r1m4, r1m5,  &
                 r2, t(20), tol, xnu(20), xx, film, st, ct, ts, slak, yy
INTEGER       :: i, icase, ifnu, il, ir, irb, it, itl, i4, k, kk, kode, k1,  &
                 k2, lflg, m, mflg, n, nu, nz, n1, ierr, keps(20),  &
                 kdo(20), nl, nul
COMPLEX (dp), PARAMETER  :: cip(4) = (/ (1.0_dp,0.0_dp), (0.0_dp,1.0_dp),  &
                                        (-1.0_dp,0.0_dp), (0.0_dp,-1.0_dp) /)
INTEGER, PARAMETER  :: mqc = 1, lun = 7

OPEN (lun, FILE='CQCBK.OUT')
!-----------------------------------------------------------------------
!     SET PARAMETERS RELATED TO MACHINE CONSTANTS.
!     TOL IS THE APPROXIMATE UNIT ROUNDOFF LIMITED TO 1.0E-18.
!     ELIM IS THE APPROXIMATE EXPONENTIAL OVER- AND UNDERFLOW LIMIT.
!     EXP(-ELIM).LT.EXP(-ALIM)=EXP(-ELIM)/TOL    AND
!     EXP(ELIM).GT.EXP(ALIM)=EXP(ELIM)*TOL       ARE INTERVALS NEAR
!     UNDERFLOW AND OVERFLOW LIMITS WHERE SCALED ARITHMETIC IS DONE.
!     RL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC EXPANSION FOR LARGE Z.
!     DIG = NUMBER OF BASE 10 DIGITS IN TOL = 10**(-DIG).
!     FNUL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC SERIES FOR LARGE FNU
!-----------------------------------------------------------------------
r1m4 = EPSILON(0.0_dp)
tol = MAX(r1m4, 1.0D-18)
aa = -LOG10(r1m4)
k1 = MINEXPONENT(0.0_dp)
k2 = MAXEXPONENT(0.0_dp)
r1m5 = LOG10( REAL(RADIX(0.0_dp), KIND=dp) )
k = MIN(ABS(k1), ABS(k2))
elim = 2.303_dp * (k*r1m5 - 3.0_dp)
ab = aa * 2.303_dp
alim = elim + MAX(-ab, -41.45_dp)
dig = MIN(aa,18.0_dp)
fnul = 10.0_dp + 6.0_dp * (dig - 3)
rl = 1.2_dp * dig + 3.0_dp
slak = 3.0_dp + 4.0_dp * (-LOG10(tol) - 7.0_dp) / 11.0_dp
slak = MAX(slak,3.0_dp)
ertol = tol * 10.0_dp ** slak
rm = 0.5_dp * (alim+elim)
rm = MIN(rm, 200.0_dp)
rm = MAX(rm, rl+10.0_dp)
r2 = MIN(fnul, rm)
!-----------------------------------------------------------------------
WRITE (lun,5000)
WRITE (lun,5100)
WRITE (lun,5200) tol, elim, alim, rl, fnul, dig
cone = CMPLX(1.0_dp, 0.0_dp, KIND=dp)
atol = 100.0_dp * tol
hpi = 2.0_dp * ATAN(1.0_dp)
pi = hpi + hpi
WRITE (lun,5300) mqc
!-----------------------------------------------------------------------
!     TEST VALUES OF Z IN -PI.LT.ARG(Z).LE.PI NEAR FORMULA BOUNDARIES
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!     KDO(K), K=1,IL  DETERMINES WHICH OF THE IL ANGLES IN -PI TO PI
!     ARE USE TO COMPUTE VALUES OF Z
!       KDO(K) = 0  MEANS THAT THE INDEX K WILL BE USED FOR ONE OR TWO
!                   VALUES OF Z, DEPENDING ON THE CHOICE OF KEPS(K)
!              = 1  MEANS THAT THE INDEX K AND THE CORRESPONDING ANGLE
!                   WILL BE SKIPPED
!     KEPS(K), K=1,IL DETERMINES WHICH OF THE ANGLES GET INCREMENTED
!     UP AND DOWN TO PUT VALUES OF Z IN REGIONS WHERE DIFFERENT
!     FORMULAE ARE USED.
!       KEPS(K) =0  MEANS THAT THE ANGLE WILL BE USED WITHOUT CHANGE
!               =1  MEANS THAT THE ANGLE WILL BE INCREMENTED UP AND
!                   DOWN BY EPS
!     THE ANGLES TO BE USED ARE STORED IN THE T(I) ARRAY, I=1,ITL
!-----------------------------------------------------------------------
IF (mqc /= 2) THEN
  nl = 2
  il = 5
  DO  i = 1, il
    keps(i) = 0
    kdo(i) = 0
  END DO
  nul = 5
  xnu(1) = 0.0_dp
  xnu(2) = 1.0_dp
  xnu(3) = 2.0_dp
  xnu(4) = 0.5_dp * fnul
  xnu(5) = fnul + 1.1_dp
ELSE
  nl = 4
  il = 13
  DO  i = 1, il
    kdo(i) = 0
    keps(i) = 0
  END DO
  kdo(2) = 1
  kdo(6) = 1
  kdo(8) = 1
  kdo(12) = 1
  keps(3) = 1
  keps(4) = 1
  keps(5) = 1
  keps(9) = 1
  keps(10) = 1
  keps(11) = 1
  nul = 6
  xnu(1) = 0.0_dp
  xnu(2) = 0.6_dp
  xnu(3) = 1.3_dp
  xnu(4) = 2.0_dp
  xnu(5) = 0.5_dp * fnul
  xnu(6) = fnul + 1.1_dp
END IF
i = 2
eps = 0.01_dp
film = (il-1)
t(1) = -pi + eps
DO  k = 2, il
  IF (kdo(k) == 0) THEN
    t(i) = pi * (-il+2*k-1) / film
    IF (keps(k) /= 0) THEN
      ts = t(i)
      t(i) = ts - eps
      i = i + 1
      t(i) = ts + eps
    END IF
    i = i + 1
  END IF
END DO
itl = i - 1
lflg = 0
DO  kode = 1, 2
  DO  n = 1, nl
    n1 = n + 1
    DO  nu = 1, nul
      fnu = xnu(nu)
      ifnu = INT(fnu)
      ffnu = fnu - (ifnu)
      arg = hpi * ffnu
      csgn = CMPLX(COS(arg), SIN(arg), KIND=dp)
      i4 = MOD(ifnu,4) + 1
      csgn = csgn * cip(i4)
      loop120:  DO  icase = 1, 3
        irb = MIN(2,icase)
        DO  ir = irb, 4
          SELECT CASE ( icase )
            CASE (    1)
              r = (0.2_dp*(4-ir) + 2*(ir-1)) / 3.0_dp
            CASE (    2)
              r = (2*(4-ir) + r2*(ir-1)) / 3.0_dp
            CASE (    3)
              IF (r2 >= rm) CYCLE loop120
              r = (r2*(4-ir) + rm*(ir-1)) / 3.0_dp
          END SELECT

          loop100:  DO  it = 1, itl
            ct = COS(t(it))
            st = SIN(t(it))
            IF (ABS(ct) < atol) ct = 0.0_dp
            IF (ABS(st) < atol) st = 0.0_dp
            xx = r * ct
            yy = r * st
            z = CMPLX(xx, yy, KIND=dp)
            IF (xx >= 0.0_dp) THEN
!-----------------------------------------------------------------------
!     WRONSKIAN CHECKS IN THE RIGHT HALF PLANE
!-----------------------------------------------------------------------
              CALL cbesi(z, fnu, kode, n1, w, nz, ierr)
              IF (nz /= 0 .OR. ierr /= 0) CYCLE loop100
              CALL cbesk(z, fnu, kode, n1, y, nz, ierr)
              IF (nz /= 0 .OR. ierr /= 0) CYCLE loop100
!-----------------------------------------------------------------------
!     ADJUSTMENTS TO WRONSKIAN DUE TO SCALING OF I AND K FUNCTIONS
!     ON KODE=2
!-----------------------------------------------------------------------
              cv = cone / z
              IF (kode == 2) THEN
                cv = cv * CMPLX(COS(yy), SIN(yy), KIND=dp)
              END IF
              mflg = 0
              kk = 0
              DO  i = 1, n
                cw = w(i) * y(i+1)
                cy = w(i+1) * y(i)
                cy = cy + cw - cv
                er = ABS(cy) / ABS(cv)
                aer(i) = er
                IF (er > ertol) THEN
                  IF (kk == 0) THEN
                    mflg = 1
                    kk = i
                  END IF
                END IF
              END DO
            ELSE
!-----------------------------------------------------------------------
!     ANALYTIC CONTINUATION FORMULA CHECKS FOR LEFT HALF PLANE IN TERMS
!     OF H(FNU,1,Z) AND H(FNU,2,Z)
!-----------------------------------------------------------------------
              zz = z
              IF (yy < 0.0_dp) THEN
                zz = CONJG(z)
              END IF
              zr = zz * CMPLX(0.0_dp, 1.0_dp, KIND=dp)
              m = 1
              CALL cbesh(zr, fnu, kode, m, n, w, nz, ierr)
              IF (ierr /= 0) CYCLE loop100
              m = 2
              CALL cbesh(zr, fnu, kode, m, n, v, nz, ierr)
              IF (ierr /= 0) CYCLE loop100
              CALL cbesk(z, fnu, kode, n, y, nz, ierr)
              IF (nz /= 0 .OR. ierr /= 0) CYCLE loop100
              coe = CMPLX(0.0_dp, -hpi, KIND=dp)
              mflg = 0
              kk = 0
              aa = 2.0_dp * COS(pi*ffnu)
              IF (MOD(ifnu, 2) /= 0) aa = -aa
              c1 = CMPLX(aa, 0.0_dp, KIND=dp)
              c2 = csgn
              DO  i = 1, n
                c3 = c1
                c4 = c2
                IF (kode == 2) THEN
!-----------------------------------------------------------------------
!     ADJUSTMENTS TO COEFICIENTS DUE TO SCALING OF H(FNU,1,Z) AND
!     H(FNU,2,Z) FUNCTIONS ON KODE = 2.
!-----------------------------------------------------------------------
                  ab = ABS(v(i))
                  aa = LOG(ab) + xx + xx
                  IF (aa > elim) CYCLE loop100
                  IF (aa < -elim) THEN
                    c3 = CMPLX(0.0_dp, 0.0_dp, KIND=dp)
                  ELSE
                    cw = zz + zz
                    c3 = c3 * EXP(cw)
                  END IF
                END IF
                cy = (c3*CONJG(c2)*v(i)+c4*w(i)) * coe
                IF (yy < 0.0_dp) THEN
                  cy = CONJG(cy)
                END IF
                er = ABS(cy-y(i)) / ABS(y(i))
                aer(i) = er
                IF (er > ertol) THEN
                  IF (kk == 0) THEN
                    mflg = 1
                    kk = i
                  END IF
                END IF
                c2 = c2 * CMPLX(0.0_dp, 1.0_dp, KIND=dp)
                c1 = -c1
              END DO
            END IF
            IF (mflg /= 0) THEN
              IF (lflg /= 1) THEN
                WRITE (lun,5400) ertol
                WRITE (lun,5500)
                WRITE (lun,5600)
                lflg = 1
              END IF
              WRITE (lun,5700) kode, n, ir, it, icase, kk
              WRITE (lun,5800) aer(1:n)
              WRITE (lun,5800) z, fnu, y(kk)
            END IF
          END DO loop100
        END DO
      END DO loop120
    END DO
  END DO
END DO
IF (lflg == 0) WRITE (lun,5900)
STOP

5000 FORMAT (' QUICK CHECK ROUTINE FOR THE K BESSEL FUNCTION FROM CBESK'/)
5100 FORMAT (' PARAMETERS TOL,ELIM,ALIM,RL,FNUL,DIG')
5200 FORMAT (6E12.4/)
5300 FORMAT (/' CHECKS IN THE (Z,FNU) SPACE WITH MQC = ',i2/)
5400 FORMAT (/ ' CASES WHICH VIOLATE THE RELATIVE ERROR TEST WITH ERTOL =',  &
             e12.4/)
5500 FORMAT (/' OUTPUT FORMAT'/' KODE,N,IR,IT,ICASE,KK')
5600 FORMAT (' ER(K),K=1,N'/  &
             ' Z,FNU,Y(KK)        KK=INDEX OF FIRST NON-ZERO PAIR'/)
5700 FORMAT (6I5)
5800 FORMAT (6E12.4)
5900 FORMAT (/' QUICK CHECKS OK'/)
END PROGRAM cqcbk
