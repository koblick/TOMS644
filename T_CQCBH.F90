PROGRAM cqcbh

! Code converted using TO_F90 by Alan Miller
! Date: 2002-02-08  Time: 17:53:21

!***DATE WRITTEN   830501   (YYMMDD)
!***REVISION DATE  890801, 930101   (YYMMDD)

!  CQCBH IS A QUICK CHECK ROUTINE FOR THE COMPLEX H BESSEL FUNCTIONS
!  GENERATED BY SUBROUTINE CBESH.

!  CQCBH GENERATES SEQUENCES OF H BESSEL FUNCTIONS FOR KIND 2 FROM
!  CBESH AND CHECKS THEM AGAINST ANALYTIC CONTINUATION FORMULAS
!  IN THE (Z,FNU) SPACE:

!  KODE = 1 TESTS (ANALYTIC CONTINUATION FORMULAE, I**2 = -1):

!  H(FNU,2,Z)=-EXP(I*PI*FNU)*H(FNU,1,-Z),       -PI < ARG(Z) <= 0

!            = 2*COS(PI*FNU)*H(FNU,2,-Z) + EXP(I*PI*FNU)*H(FNU,1,-Z),

!                                                0 < ARG(Z) <= PI

!  KODE = 2 TESTS FOR KINDS 1 AND 2:

!         EXP(-I*Z)*H(FNU,1,Z) = [EXP(-I*Z)*H(FNU,1,Z)]

!         EXP( I*Z)*H(FNU,2,Z) = [EXP( I*Z)*H(FNU,2,Z)]

!  WHERE THE LEFT SIDE IS COMPUTED WITH KODE = 1 AND THE RIGHT SIDE
!  WITH KODE = 2.

!  THE PARAMETER MQC CAN HAVE VALUES 1 (THE DEFAULT) FOR A FASTER,
!  LESS DEFINITIVE TEST OR 2 FOR A SLOWER, MORE DEFINITIVE TEST.

!  MACHINE CONSTANTS ARE DEFINED IN FUNCTIONS I1MACH, R1MACH, AND D1MACH.
!  THESE MUST BE SELECTED BY THE USER OR SET ACCORDING TO PROLOGUE INSTRUCTIONS.

USE Complex_Bessel
IMPLICIT NONE

COMPLEX (dp)  :: cw, ci, z, zn, csgn
REAL (dp)     :: aa, ab, alim, atol, av, ct, dig, ERR, xx, yy, elim, eps,  &
                 er, ertol, fnu, fnul, pi, r, rl, rm, r1m4, r1m5, r2, st,  &
                 tol, ts, slak, film
INTEGER       :: i, icase, ierr, ihp, il, ir, irb, it, itl, k, kode, kk,  &
                 k1, k2, lflg, mflg, m, n, nu, nz1, nz2, nz3, nl, nul
REAL (dp)     :: t(20), aer(20), xnu(20)
COMPLEX (dp)  :: u(20), v(20), w(20), y(20)
INTEGER       :: keps(20), kdo(20)
INTEGER, PARAMETER  :: lun = 7, mqc = 2

OPEN (lun, FILE='CQCBH.OUT')
!-----------------------------------------------------------------------
!     SET PARAMETERS RELATED TO MACHINE CONSTANTS.
!     TOL IS THE APPROXIMATE UNIT ROUNDOFF LIMITED TO 1.0E-18.
!     ELIM IS THE APPROXIMATE EXPONENTIAL OVER- AND UNDERFLOW LIMIT.
!     EXP(-ELIM) < EXP(-ALIM)=EXP(-ELIM)/TOL    AND
!     EXP(ELIM) > EXP(ALIM)=EXP(ELIM)*TOL       ARE INTERVALS NEAR
!     UNDERFLOW AND OVERFLOW LIMITS WHERE SCALED ARITHMETIC IS DONE.
!     RL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC EXPANSION FOR LARGE Z.
!     DIG = NUMBER OF BASE 10 DIGITS IN TOL = 10**(-DIG).
!     FNUL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC SERIES FOR LARGE FNU
!-----------------------------------------------------------------------
r1m4 = EPSILON(0.0_dp)
tol = MAX(r1m4, 1.0D-18)
aa = -LOG10(r1m4)
k1 = MINEXPONENT(0.0_dp)
k2 = MAXEXPONENT(0.0_dp)
r1m5 = LOG10( REAL(RADIX(0.0_dp), KIND=dp) )
k = MIN(ABS(k1), ABS(k2))
elim = 2.303_dp * (k*r1m5 - 3.0_dp)
ab = aa * 2.303_dp
alim = elim + MAX(-ab, -41.45_dp)
dig = MIN(aa,18.0_dp)
fnul = 10.0_dp + 6.0_dp * (dig - 3)
rl = 1.2_dp * dig + 3.0_dp
slak = 3.0_dp + 4.0_dp * (-LOG10(tol) - 7.0_dp) / 11.0_dp
slak = MAX(slak,3.0_dp)
ertol = tol * 10.0_dp ** slak
rm = 0.5_dp * (alim+elim)
rm = MIN(rm, 200.0_dp)
rm = MAX(rm, rl+10.0_dp)
r2 = MIN(fnul, rm)
!-----------------------------------------------------------------------
WRITE (lun,5000)
WRITE (lun,5100)
WRITE (lun,5200) tol, elim, alim, rl, fnul, dig
atol = 100.0_dp * tol
pi = 4.0_dp * ATAN(1.0_dp)
ci = CMPLX(0.0_dp, 1.0_dp, KIND=dp)
WRITE (lun,5300) mqc
!-----------------------------------------------------------------------
!     TEST VALUES OF Z IN -PI < ARG(Z) <= PI NEAR FORMULA BOUNDARIES
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!     KDO(K), K=1,IL  DETERMINES WHICH OF THE IL ANGLES IN -PI TO PI
!     ARE USE TO COMPUTE VALUES OF Z
!       KDO(K) = 0  MEANS THAT THE INDEX K WILL BE USED FOR ONE OR TWO
!                   VALUES OF Z, DEPENDING ON THE CHOICE OF KEPS(K)
!              = 1  MEANS THAT THE INDEX K AND THE CORRESPONDING ANGLE
!                   WILL BE SKIPPED
!     KEPS(K), K=1,IL DETERMINES WHICH OF THE ANGLES GET INCREMENTED
!     UP AND DOWN TO PUT VALUES OF Z IN REGIONS WHERE DIFFERENT
!     FORMULAE ARE USED.
!       KEPS(K) =0  MEANS THAT THE ANGLE WILL BE USED WITHOUT CHANGE
!               =1  MEANS THAT THE ANGLE WILL BE INCREMENTED UP AND
!                   DOWN BY EPS
!     THE ANGLES TO BE USED ARE STORED IN THE T(I) ARRAY, I=1,ITL
!-----------------------------------------------------------------------
IF (mqc /= 2) THEN
  nl = 2
  il = 5
  DO  i = 1, il
    keps(i) = 0
    kdo(i) = 0
  END DO
  nul = 5
  xnu(1) = 0.0_dp
  xnu(2) = 1.0_dp
  xnu(3) = 2.0_dp
  xnu(4) = 0.5_dp * fnul
  xnu(5) = fnul + 1.1_dp
ELSE
  nl = 4
  il = 13
  DO  i = 1, il
    kdo(i) = 0
    keps(i) = 0
  END DO
  kdo(2) = 1
  kdo(6) = 1
  kdo(8) = 1
  kdo(12) = 1
  keps(3) = 1
  keps(4) = 1
  keps(5) = 1
  keps(9) = 1
  keps(10) = 1
  keps(11) = 1
  nul = 6
  xnu(1) = 0.0_dp
  xnu(2) = 0.6_dp
  xnu(3) = 1.3_dp
  xnu(4) = 2.0_dp
  xnu(5) = 0.5_dp * fnul
  xnu(6) = fnul + 1.1_dp
END IF
i = 2
eps = 0.01_dp
film = il - 1
t(1) = -pi + eps
DO  k = 2, il
  IF (kdo(k) == 0) THEN
    t(i) = pi * (-il + 2*k - 1) / film
    IF (keps(k) /= 0) THEN
      ts = t(i)
      t(i) = ts - eps
      i = i + 1
      t(i) = ts + eps
    END IF
    i = i + 1
  END IF
END DO
itl = i - 1
lflg = 0
DO  kode = 1, 2
  DO  n = 1, nl
    DO  nu = 1, nul
      fnu = xnu(nu)
      loop120:  DO  icase = 1, 3
        irb = MIN(icase,2)
        DO  ir = irb, 3
          SELECT CASE ( icase )
            CASE (    1)
              r = (eps*(3-ir) + 2*(ir-1)) / 2.0_dp

            CASE (    2)
              r = (2*(3-ir) + r2*(ir-1)) / 2.0_dp

            CASE (    3)
              IF (r2 >= rm) CYCLE loop120
              r = (r2*(3-ir) + rm*(ir-1)) / 2.0_dp
          END SELECT

          DO  it = 1, itl
            ct = COS(t(it))
            st = SIN(t(it))
            IF (ABS(ct) < atol) ct = 0.0_dp
            IF (ABS(st) < atol) st = 0.0_dp
            xx = r * ct
            yy = r * st
            z = CMPLX(xx, yy, KIND=dp)
            IF (kode == 1) THEN
              m = 2
              CALL cbesh(z, fnu, kode, m, n, y, nz1, ierr)
              IF (ierr /= 0 .OR. nz1 /= 0) CYCLE
              IF (st < 0.0_dp .OR. (st == 0.0_dp .AND. ct > 0.0_dp)) THEN
                ihp = 1
                zn = -z
                m = 1
                CALL cbesh(zn, fnu, kode, m, n, w, nz2, ierr)
                IF (ierr /= 0 .OR. nz2 /= 0) CYCLE
              ELSE
                ihp = 2
                zn = -z
                m = 2
                CALL cbesh(zn, fnu, kode, m, n, w, nz3, ierr)
                IF (ierr /= 0 .OR. nz3 /= 0) CYCLE
                m = 1
                CALL cbesh(zn, fnu, kode, m, n, v, nz2, ierr)
                IF (ierr /= 0 .OR. nz2 /= 0) CYCLE
              END IF
              ab = MOD(fnu, 2.0_dp) * pi
              csgn = CMPLX(COS(ab), SIN(ab), KIND=dp)
              mflg = 0
              DO  i = 1, n
                ab = fnu + (i-1)
                aa = MAX(0.5_dp, ab)
                IF (ihp == 1) THEN
                  v(i) = -csgn * w(i)
                  cw = y(i) - v(i)
                ELSE
                  v(i) = 2.0_dp * REAL(csgn, KIND=dp) * w(i) + csgn * v(i)
                  cw = y(i) - v(i)
                END IF
                av = ABS(y(i))
                er = ABS(cw)
                IF (yy == 0.0_dp) THEN
                  IF (ABS(xx) < aa) er = er / av
                ELSE
                  er = er / av
                END IF
                aer(i) = er
                IF (er > ertol) mflg = 1
                csgn = -csgn
              END DO
            ELSE
              m = 1
              kk = 1
              CALL cbesh(z, fnu, kk, m, n, u, nz1, ierr)
              IF (ierr /= 0 .OR. nz1 /= 0) CYCLE
              CALL cbesh(z, fnu, kode, m, n, v, nz2, ierr)
              IF (ierr /= 0 .OR. nz2 /= 0) CYCLE
              m = 2
              kk = 1
              CALL cbesh(z, fnu, kk, m, n, w, nz1, ierr)
              IF (ierr /= 0 .OR. nz1 /= 0) CYCLE
              CALL cbesh(z, fnu, kode, m, n, y, nz2, ierr)
              IF (ierr /= 0 .OR. nz2 /= 0) CYCLE
              zn = ci * z
              zn = EXP(zn)
              mflg = 0
              DO  i = 1, n
                ab = fnu + (i-1)
                aa = MAX(0.5_dp, ab)
                cw = u(i) / zn - v(i)
                er = ABS(cw)
                av = ABS(v(i))
                IF (yy == 0.0_dp) THEN
                  IF (ABS(xx) < aa) er = er / av
                ELSE
                  er = er / av
                END IF
                ERR = er
                IF (er > ertol) mflg = 1
                cw = zn * w(i) - y(i)
                er = ABS(cw)
                av = ABS(y(i))
                IF (yy == 0.0_dp) THEN
                  IF (ABS(xx) < aa) er = er / av
                ELSE
                  er = er / av
                END IF
                IF (er > ertol) mflg = 1
                aer(i) = er + ERR
              END DO
            END IF
            IF (mflg /= 0) THEN
              IF (lflg /= 1) THEN
                WRITE (lun,5400) ertol
                WRITE (lun,5500)
                WRITE (lun,5600)
                lflg = 1
              END IF
              WRITE (lun,5700) kode, n, ir, it, icase
              WRITE (lun,5800) aer(1:n)
              WRITE (lun,5800) z, fnu, v(1), y(1)
            END IF
          END DO
        END DO
      END DO loop120
    END DO
  END DO
END DO
IF (lflg == 0) WRITE (lun,5900)
STOP

5000 FORMAT (' QUICK CHECK ROUTINE FOR THE H BESSEL FUNCTIONS FROM CBESH'/)
5100 FORMAT (' PARAMETERS TOL,ELIM,ALIM,RL,FNUL,DIG')
5200 FORMAT (6E12.4/)
5300 FORMAT (/' CHECKS IN THE (Z,FNU) SPACE WITH MQC = ',i2/)
5400 FORMAT (/' CASES WHICH VIOLATE THE RELATIVE ERROR TEST WITH ERTOL =', e12.4/)
5500 FORMAT (/' OUTPUT FORMAT'/ ' KODE,N,IR,IT,ICASE')
5600 FORMAT (' ER(K),K=1,N'/ ' Z,FNU,V(1),Y(1)')
5700 FORMAT (5I5)
5800 FORMAT (7E12.4)
5900 FORMAT (/' QUICK CHECKS OK'/)
END PROGRAM cqcbh
