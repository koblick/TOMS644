PROGRAM cqcai

! Code converted using TO_F90 by Alan Miller
! Date: 2002-02-08  Time: 17:54:08

!***DATE WRITTEN   830501   (YYMMDD)
!***REVISION DATE  890801, 930101   (YYMMDD)

!     CQCAI IS A QUICK CHECK ROUTINE FOR THE COMPLEX AIRY FUNCTIONS
!     GENERATED BY SUBROUTINES CAIRY AND CBIRY.

!     CQCAI GENERATES AIRY FUNCTIONS AND THEIR DERIVATIVES FROM CAIRY
!     AND CBIRY AND CHECKS THEM AGAINST THE WRONSKIAN EVALUATION IN THE
!     REGION -PI/3  <=  ARG(Z)  <=  PI/3:

!                 AI(Z)*BI'(Z)-AI'(Z)*BI(Z)=1/PI.

!     IN THE REMAINDER OF THE CUT PLANE, THE IDENTITIES

!              AI(Z)  = SQRT(-Z)*( J(-1/3,ZR) + J(1/3,ZR) )/3

!              AI'(Z) =        Z*( J(-2/3,ZR) - J(2/3,ZR) )/3

!       BI(Z)  =   I*SQRT(-Z/3)*( C1*H(1/3,1,ZR) - C2*H(1/3,2,ZR) )/2

!       BI'(Z) = I*(-Z)/SQRT(3)*( C2*H(2/3,1,ZR) - C1*H(2/3,2,ZR) )/2

!     ARE CHECKED WHERE ZR = (2/3)(-Z)**(3/2) WITH C1 = EXP(PI*I/6),
!     C2 = CONJG(C1) AND I**2 = -1.

!     THE PARAMETER MQC CAN HAVE VALUES 1 (THE DEFAULT) FOR A FASTER,
!     LESS DEFINITIVE TEST OR 2 FOR A SLOWER, MORE DEFINITIVE TEST.

!     MACHINE CONSTANTS ARE DEFINED IN FUNCTIONS I1MACH, R1MACH, AND
!     D1MACH. THESE MUST BE SELECTED BY THE USER OR SET ACCORDING TO
!     PROLOGUE INSTRUCTIONS.

USE Complex_Bessel
IMPLICIT NONE

COMPLEX (dp)  :: ca, cav, chi, ci, cona, conb, conc, cond, con1, con2, cv,  &
                 cw, cy, w(20), y(20), yy(20), z, zr, zw, sc
REAL (dp)     :: aa, ab, alim, atol, av, ct, c13, c23, c43, zx, zy, dig,  &
                 elim, eps, er(5), ertol, fnul, fpi, hpi, pi, r, rl, rpi, &
                 r1m4, r1m5, spi, st, slak, t(20), tol, rm, film, pi3, ts
INTEGER       :: i, icase, icl, il, ir, irset, it, itl, j, jb, jl, k,  &
                 keps(20), kode, k1, k2, lflg, nz, ierr, irb, kdo(20)
INTEGER, PARAMETER   :: mqc = 2, lun = 7

OPEN (lun, FILE='CQCAI.OUT')
!-----------------------------------------------------------------------
!     SET PARAMETERS RELATED TO MACHINE CONSTANTS.
!     TOL IS THE APPROXIMATE UNIT ROUNDOFF LIMITED TO 1.0E-18.
!     ELIM IS THE APPROXIMATE EXPONENTIAL OVER- AND UNDERFLOW LIMIT.
!     EXP(-ELIM) < EXP(-ALIM)=EXP(-ELIM)/TOL    AND
!     EXP(ELIM) > EXP(ALIM)=EXP(ELIM)*TOL       ARE INTERVALS NEAR
!     UNDERFLOW AND OVERFLOW LIMITS WHERE SCALED ARITHMETIC IS DONE.
!     RL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC EXPANSION FOR LARGE Z.
!     DIG = NUMBER OF BASE 10 DIGITS IN TOL = 10**(-DIG).
!     FNUL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC SERIES FOR LARGE FNU
!-----------------------------------------------------------------------
r1m4 = EPSILON(0.0_dp)
tol = MAX(r1m4, 1.0D-18)
aa = -LOG10(r1m4)
k1 = MINEXPONENT(0.0_dp)
k2 = MAXEXPONENT(0.0_dp)
r1m5 = LOG10( REAL(RADIX(0.0_dp), KIND=dp) )
k = MIN(ABS(k1), ABS(k2))
elim = 2.303_dp * (k*r1m5 - 3.0_dp)
ab = aa * 2.303_dp
alim = elim + MAX(-ab, -41.45_dp)
dig = MIN(aa,18.0_dp)
fnul = 10.0_dp + 6.0_dp * (dig - 3)
rl = 1.2_dp * dig + 3.0_dp
slak = 3.0_dp + 4.0_dp * (-LOG10(tol) - 7.0_dp) / 11.0_dp
slak = MAX(slak,3.0_dp)
ertol = tol * 10.0_dp ** slak
rm = 0.5_dp * (alim+elim)
rm = MIN(rm, 200.0_dp)
rm = MAX(rm, rl+10.0_dp)
!-----------------------------------------------------------------------
WRITE (lun,5000)
WRITE (lun,5100)
WRITE (lun,5200) tol, elim, alim, rl, fnul, dig
atol = 100.0_dp * tol
fpi = ATAN(1.0_dp)
hpi = fpi + fpi
pi = hpi + hpi
rpi = 1.0_dp / pi
spi = pi / 6.0_dp
con1 = CMPLX(COS(spi), SIN(spi), KIND=dp)
con2 = CONJG(con1)
pi3 = spi + spi
c13 = 1.0_dp / 3.0_dp
c23 = c13 + c13
c43 = c23 + c23
av = SQRT(c13)
cav = CMPLX(av, 0.0_dp, KIND=dp)
chi = CMPLX(0.0_dp, 0.5_dp, KIND=dp)
ci = CMPLX(0.0_dp, 1.0_dp, KIND=dp)
WRITE (lun,5300) mqc
!-----------------------------------------------------------------------
!     TEST VALUES OF Z IN -PI < ARG(Z) <= PI
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!     KDO(K), K=1,IL  DETERMINES WHICH OF THE IL ANGLES IN -PI TO PI
!     ARE USE TO COMPUTE VALUES OF Z
!       KDO(K) = 0  MEANS THAT THE INDEX K WILL BE USED FOR ONE OR TWO
!                   VALUES OF Z, DEPENDING ON THE CHOICE OF KEPS(K)
!              = 1  MEANS THAT THE INDEX K AND THE CORRESPONDING ANGLE
!                   WILL BE SKIPPED
!     KEPS(K), K=1,IL DETERMINES WHICH OF THE ANGLES GET INCREMENTED
!     UP AND DOWN TO PUT VALUES OF Z IN REGIONS WHERE DIFFERENT
!     FORMULAE ARE USED.
!       KEPS(K) =0  MEANS THAT THE ANGLE WILL BE USED WITHOUT CHANGE
!               =1  MEANS THAT THE ANGLE WILL BE INCREMENTED UP AND
!                   DOWN BY EPS
!     THE ANGLES TO BE USED ARE STORED IN THE T(I) ARRAY, I=1,ITL
!-----------------------------------------------------------------------
IF (mqc /= 2) THEN
  icl = 1
  il = 5
  DO  i = 1, il
    kdo(i) = 0
    keps(i) = 0
  END DO
ELSE
  icl = 2
  il = 7
  DO  i = 1, il
    kdo(i) = 0
    keps(i) = 0
  END DO
  keps(2) = 1
  keps(3) = 1
  keps(5) = 1
  keps(6) = 1
END IF
i = 2
eps = 0.01_dp
film = (il-1)
t(1) = -pi + eps
DO  k = 2, il
  IF (kdo(k) == 0) THEN
    t(i) = pi * (-il+2*k-1) / film
    IF (keps(k) /= 0) THEN
      ts = t(i)
      t(i) = ts - eps
      i = i + 1
      t(i) = ts + eps
    END IF
    i = i + 1
  END IF
END DO
itl = i - 1
lflg = 0
DO  icase = 1, icl
  DO  kode = 1, 2
    DO  irset = 1, 3
      irb = MIN(irset,2)
      DO  ir = irb, 4
        SELECT CASE ( irset )
          CASE (    1)
            r = (0.2_dp*(4-ir) + 2*(ir-1)) / 3.0_dp
          CASE (    2)
            r = (2*(4-ir) + rl*(ir-1)) / 3.0_dp
          CASE (    3)
            r = (rl*(4-ir) + rm*(ir-1)) / 3.0_dp
        END SELECT

        DO  it = 1, itl
          ct = COS(t(it))
          st = SIN(t(it))
          IF (ABS(ct) < atol) ct = 0.0_dp
          IF (ABS(st) < atol) st = 0.0_dp
          zx = r * ct
          zy = r * st
          z = CMPLX(zx, zy, KIND=dp)
          IF (ABS(t(it)) <= pi3) THEN
!-----------------------------------------------------------------------
!     WRONSKIAN CHECK IN -PI/3 < ARG(Z) < PI/3, TEST #1
!-----------------------------------------------------------------------
            CALL cairy(z, 0, kode, y(1), nz, ierr)
            IF (nz /= 0 .OR. ierr /= 0) CYCLE
            CALL cairy(z, 1, kode, y(2), nz, ierr)
            IF (nz /= 0 .OR. ierr /= 0) CYCLE
            CALL cbiry(z, 0, kode, w(1), ierr)
            CALL cbiry(z, 1, kode, w(2), ierr)
            cw = y(1) * w(2)
            cy = y(2) * w(1)
            cv = CMPLX(rpi, 0.0_dp, KIND=dp)
            IF (kode == 2) THEN
              zr = z
              ca = SQRT(zr)
              zr = zr * ca * CMPLX(c23, 0.0_dp, KIND=dp)
              aa = REAL(zr, KIND=dp)
              aa = ABS(aa)
              ca = zr - CMPLX(aa, 0.0_dp, KIND=dp)
              cv = EXP(ca) * cv
            END IF
            cy = cw - cy - cv
            er(1) = ABS(cy) / ABS(cv)
            jb = 1
            jl = 1
          ELSE
!-----------------------------------------------------------------------
!     CHECKS IN -PI < ARG(Z) < -PI/3 AND PI/3 < ARG(Z) <= PI
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!     CHECK AI    TEST #2
!-----------------------------------------------------------------------
            CALL cairy(z, 0, kode, y(2), nz, ierr)
            IF (nz /= 0 .OR. ierr /= 0) CYCLE
            zr = -z
            cv = SQRT(zr)
            zr = zr * cv * CMPLX(c23, 0.0_dp, KIND=dp)
            CALL cbesj(zr, c23, kode, 2, yy, nz, ierr)
            IF (nz /= 0 .OR. ierr /= 0) CYCLE
            cy = CMPLX(c43, 0.0_dp, KIND=dp) * yy(1) / zr - yy(2)
            ca = yy(1)
            CALL cbesj(zr, c13, kode, 2, yy, nz, ierr)
            IF (nz /= 0 .OR. ierr /= 0) CYCLE
            IF (kode == 2) THEN
              ab = AIMAG(zr)
              ab = ABS(ab)
              cw = SQRT(z)
              zw = z * cw * CMPLX(c23, 0.0_dp, KIND=dp)
              cw = zw + CMPLX(ab, 0.0_dp, KIND=dp)
              cw = EXP(cw)
              yy(1) = yy(1) * cw
              yy(2) = yy(2) * cw
              cy = cy * cw
              ca = ca * cw
              sc = cw
            END IF
            cw = cv * CMPLX(c13, 0.0_dp, KIND=dp)
            w(2) = cw * (yy(1)+cy)
            er(2) = ABS(y(2)-w(2))
            IF (zy /= 0.0D0 .OR. zx >= 0.0D0) THEN
              er(2) = er(2) / ABS(y(2))
            ELSE
              IF (kode == 2) THEN
                er(2) = er(2) / ABS(sc)
              END IF
            END IF
!-----------------------------------------------------------------------
!     CHECK AI'   TEST #3
!-----------------------------------------------------------------------
            cy = CMPLX(c23, 0.0_dp, KIND=dp) * yy(1) / zr - yy(2)
            w(3) = z * CMPLX(c13, 0.0_dp, KIND=dp) * (cy-ca)
            CALL cairy(z, 1, kode, y(3), nz, ierr)
            er(3) = ABS(y(3)-w(3))
            IF (zy /= 0.0D0 .OR. zx >= 0.0D0) THEN
              er(3) = er(3) / ABS(y(3))
            ELSE
              IF (kode == 2) THEN
                er(3) = er(3) / ABS(sc)
              END IF
            END IF
!-----------------------------------------------------------------------
!     CHECK BI    TEST #4
!-----------------------------------------------------------------------
            CALL cbesh(zr, c13, kode, 1, 1, y, nz, ierr)
            IF (nz /= 0 .OR. ierr /= 0) CYCLE
            CALL cbesh(zr, c13, kode, 2, 1, yy, nz, ierr)
            IF (nz /= 0 .OR. ierr /= 0) CYCLE
            cona = con1
            conb = con2
            conc = con2
            cond = con1
            IF (kode == 2) THEN
              aa = REAL(zw, KIND=dp)
              aa = ABS(aa)
              zw = ci * zr - CMPLX(aa, 0.0_dp, KIND=dp)
              cw = EXP(zw)
              cona = cona * cw
              conc = conc * cw
              zw = -ci * zr - CMPLX(aa, 0.0_dp, KIND=dp)
              cw = EXP(zw)
              conb = conb * cw
              cond = cond * cw
              sc = cw
            END IF
            cw = cona * y(1) - conb * yy(1)
            cw = cv * cav * cw
            w(4) = cw * chi
            CALL cbiry(z, 0, kode, y(4), ierr)
            er(4) = ABS(y(4)-w(4))
            IF (zy /= 0.0D0 .OR. zx >= 0.0D0) THEN
              er(4) = er(4) / ABS(y(4))
            ELSE
              IF (kode == 2) THEN
                er(4) = er(4) / ABS(sc)
              END IF
            END IF
!-----------------------------------------------------------------------
!     CHECK BI'   TEST #5
!-----------------------------------------------------------------------
            CALL cbesh(zr, c23, kode, 1, 1, y, nz, ierr)
            IF (nz /= 0 .OR. ierr /= 0) CYCLE
            CALL cbesh(zr, c23, kode, 2, 1, yy, nz, ierr)
            IF (nz /= 0 .OR. ierr /= 0) CYCLE
            cw = conc * y(1) - cond * yy(1)
            cw = -z * cav * cw
            w(5) = cw * chi
            CALL cbiry(z, 1, kode, y(5), ierr)
            er(5) = ABS(y(5)-w(5))
            IF (zy /= 0.0D0 .OR. zx >= 0.0D0) THEN
              er(5) = er(5) / ABS(y(5))
            ELSE
              IF (kode == 2) THEN
                er(5) = er(5) / ABS(sc)
              END IF
            END IF
            jb = 2
            jl = 5
          END IF
          DO  j = jb, jl
            IF (er(j) >= ertol) THEN
              IF (lflg /= 1) THEN
                WRITE (lun,5400) ertol
                WRITE (lun,5500)
                WRITE (lun,5600)
                lflg = 1
              END IF
              WRITE (lun,5700) kode, ir, it, irset, icase
              WRITE (lun,5800) er(j)
              WRITE (lun,5900) j, z, y(j), w(j)
            END IF
          END DO
        END DO
      END DO
    END DO
  END DO
END DO
IF (lflg == 0) WRITE (lun,6000)
STOP

5000 FORMAT(' QUICK CHECK ROUTINE FOR THE AIRY FUNCTIONS FROM CAIRY AND CBIRY'/)
5100 FORMAT(' PARAMETERS TOL,ELIM,ALIM,RL,FNUL,DIG')
5200 FORMAT(6E12.4/)
5300 FORMAT(/' CHECKS IN THE (Z,FNU) SPACE WITH MQC = ',i2/)
5400 FORMAT(/ ' CASES WHICH VIOLATE THE RELATIVE ERROR TEST WITH ERTOL =',  &
            e12.4/)
5500 FORMAT(/' OUTPUT FORMAT'/ ' KODE,IR,IT,IRSET,ICASE')
5600 FORMAT(' ER'/ ' I, Z, Y(I), W(I), ON THE I-TH TEST, I=1,5'/)
5700 FORMAT(5I5)
5800 FORMAT(e12.4)
5900 FORMAT(i5,6E12.4)
6000 FORMAT(/' QUICK CHECKS OK'/)
END PROGRAM cqcai
