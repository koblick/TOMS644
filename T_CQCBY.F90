PROGRAM cqcby

! Code converted using TO_F90 by Alan Miller
! Date: 2002-02-08  Time: 17:54:00

!***DATE WRITTEN   830501   (YYMMDD)
!***REVISION DATE  890801, 930101   (YYMMDD)

!   CQCBY IS A QUICK CHECK ROUTINE FOR THE COMPLEX Y BESSEL FUNCTION
!   GENERATED BY SUBROUTINE CBESY.

!   CQCBY GENERATES SEQUENCES OF Y BESSEL FUNCTIONS FROM CBESY AND
!   CBESYH AND COMPARES THEM FOR A VARIETY OF VALUES IN THE (Z,FNU)
!   SPACE.  CBESYH IS AN OLD VERSION OF CBESY WHICH COMPUTES THE Y
!   FUNCTION FROM THE H FUNCTIONS OF KINDS 1 AND 2.

!   THE PARAMETER MQC CAN HAVE VALUES 1 (THE DEFAULT) FOR A FASTER,
!   LESS DEFINITIVE TEST OR 2 FOR A SLOWER, MORE DEFINITIVE TEST.

!   MACHINE CONSTANTS ARE DEFINED IN FUNCTIONS I1MACH, R1MACH, AND
!   D1MACH.  THESE MUST BE SELECTED BY THE USER OR SET ACCORDING TO
!   PROLOGUE INSTRUCTIONS.
!   N.B. There is an error in the F77 version of this program.
!   Single-precision machine constants are used for the minimum and maximum
!   exponents.

USE Complex_Bessel
IMPLICIT NONE

COMPLEX (dp)  :: cw, v(20), w(20), z
REAL (dp)     :: aa, ab, aer(20), alim, atol, av, dig, elim, eps, er,  &
                 ertol, ffnu, fnu, fnul, pi, r, rl, rm, r1m4, r1m5, r2, t(20), &
                 tol, xnu(20), xx, yy, ct, st, ts, slak, film
INTEGER       :: i, icase, il, ir, irb, it, itl, k, kk, kode, k1, k2,  &
                 lflg, mflg, n, nu, nz1, nz2, ierr, keps(20), kdo(20), nl, nul
INTEGER, PARAMETER  :: mqc = 1, lun = 7

OPEN (lun, FILE='CQCBY.OUT')
!-----------------------------------------------------------------------
!     SET PARAMETERS RELATED TO MACHINE CONSTANTS.
!     TOL IS THE APPROXIMATE UNIT ROUNDOFF LIMITED TO 1.0E-18.
!     ELIM IS THE APPROXIMATE EXPONENTIAL OVER- AND UNDERFLOW LIMIT.
!     EXP(-ELIM) < EXP(-ALIM)=EXP(-ELIM)/TOL    AND
!     EXP(ELIM) > EXP(ALIM)=EXP(ELIM)*TOL       ARE INTERVALS NEAR
!     UNDERFLOW AND OVERFLOW LIMITS WHERE SCALED ARITHMETIC IS DONE.
!     RL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC EXPANSION FOR LARGE Z.
!     DIG = NUMBER OF BASE 10 DIGITS IN TOL = 10**(-DIG).
!     FNUL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC SERIES FOR LARGE FNU
!-----------------------------------------------------------------------
r1m4 = EPSILON(0.0_dp)
tol = MAX(r1m4, 1.0D-18)
aa = -LOG10(r1m4)
k1 = MINEXPONENT(0.0_dp)
k2 = MAXEXPONENT(0.0_dp)
r1m5 = LOG10( REAL(RADIX(0.0_dp), KIND=dp) )
k = MIN(ABS(k1), ABS(k2))
elim = 2.303_dp * (k*r1m5 - 3.0_dp)
ab = aa * 2.303_dp
alim = elim + MAX(-ab, -41.45_dp)
dig = MIN(aa,18.0_dp)
fnul = 10.0_dp + 6.0_dp * (dig - 3)
rl = 1.2_dp * dig + 3.0_dp
slak = 3.0_dp + 4.0_dp * (-LOG10(tol) - 7.0_dp) / 11.0_dp
slak = MAX(slak,3.0_dp)
ertol = tol * 10.0_dp ** slak
rm = 0.5_dp * (alim + elim)
rm = MIN(rm, 200.0_dp)
rm = MAX(rm, rl+10.0_dp)
r2 = MIN(fnul, rm)
!-----------------------------------------------------------------------
WRITE (lun,5000)
WRITE (lun,5100)
WRITE (lun,5200) tol, elim, alim, rl, fnul, dig
WRITE (lun, '(a, 3g15.6)') ' RM, R2, Diff = ', rm, r2, rm-r2
atol = 100.0_dp * tol
pi = 4.0_dp * ATAN(1.0_dp)
WRITE (lun,5300) mqc
!-----------------------------------------------------------------------
!     TEST VALUES OF Z IN -PI/2 < ARG(Z) <= PI
!-----------------------------------------------------------------------
!     KDO(K), K=1,IL  DETERMINES WHICH OF THE IL ANGLES IN -PI TO PI
!     ARE USED TO COMPUTE VALUES OF Z
!       KDO(K) = 0  MEANS THAT THE INDEX K WILL BE USED FOR ONE OR TWO
!                   VALUES OF Z, DEPENDING ON THE CHOICE OF KEPS(K)
!              = 1  MEANS THAT THE INDEX K AND THE CORRESPONDING ANGLE
!                   WILL BE SKIPPED
!     KEPS(K), K=1,IL DETERMINES WHICH OF THE ANGLES GET INCREMENTED
!     UP AND DOWN TO PUT VALUES OF Z IN REGIONS WHERE DIFFERENT
!     FORMULAE ARE USED.
!       KEPS(K) =0  MEANS THAT THE ANGLE WILL BE USED WITHOUT CHANGE
!               =1  MEANS THAT THE ANGLE WILL BE INCREMENTED UP AND
!                   DOWN BY EPS
!     THE ANGLES TO BE USED ARE STORED IN THE T(I) ARRAY, I=1,ITL
!-----------------------------------------------------------------------
IF (mqc /= 2) THEN
  nl = 2
  il = 5
  DO  i = 1, il
    keps(i) = 0
    kdo(i) = 0
  END DO
  kdo(5) = 1
  nul = 5
  xnu(1) = 0.0_dp
  xnu(2) = 1.0_dp
  xnu(3) = 2.0_dp
  xnu(4) = 0.5_dp * fnul
  xnu(5) = fnul + 1.2_dp
ELSE
  nl = 4
  il = 13
  DO  i = 1, il
    kdo(i) = 0
    keps(i) = 0
  END DO
  kdo(2) = 1
  kdo(6) = 1
  kdo(8) = 1
  kdo(12) = 1
  keps(3) = 1
  keps(4) = 1
  keps(5) = 1
  keps(9) = 1
  keps(10) = 1
  keps(11) = 1
  nul = 6
  xnu(1) = 0.0_dp
  xnu(2) = 0.6_dp
  xnu(3) = 1.3_dp
  xnu(4) = 2.0_dp
  xnu(5) = 0.5_dp * fnul
  xnu(6) = fnul + 1.2_dp
END IF
i = 2
eps = 0.01_dp
film = il - 1
t(1) = -pi + eps
DO  k = 2, il
  IF (kdo(k) == 0) THEN
    t(i) = pi * (-il+2*k-1) / film
    IF (keps(k) /= 0) THEN
      ts = t(i)
      t(i) = ts - eps
      i = i + 1
      t(i) = ts + eps
    END IF
    i = i + 1
  END IF
END DO
itl = i - 1
lflg = 0
DO  kode = 1, 2
  DO  n = 1, nl
    DO  nu = 1, nul
      fnu = xnu(nu)
      ffnu = fnu - INT(fnu)
      loop110:  DO  icase = 1, 3
        irb = MIN(2,icase)
        DO  ir = irb, 4
          SELECT CASE ( icase )
            CASE ( 1 )
              r = (eps*(4-ir) + 2*(ir-1)) / 3.0_dp
            CASE ( 2 )
              r = (2*(4-ir) + r2*(ir-1)) / 3.0_dp
            CASE ( 3 )
              IF (r2 == rm) CYCLE loop110
              r = (r2*(4-ir) + rm*(ir-1)) / 3.0_dp
          END SELECT

          DO  it = 1, itl
            ct = COS(t(it))
            st = SIN(t(it))
            IF (ABS(ct) < atol) ct = 0.0_dp
            IF (ABS(st) < atol) st = 0.0_dp
            z = CMPLX(r*ct, r*st, KIND=dp)
            xx = REAL(z, KIND=dp)
            yy = AIMAG(z)
            CALL cbesy(z, fnu, kode, n, v, nz2, ierr)
            IF (nz2 == 0 .AND. ierr == 0) THEN
              CALL cbesyh(z, fnu, kode, n, w, nz1, ierr)
              IF (nz1 == 0 .AND. ierr == 0) THEN
                mflg = 0
                DO  i = 1, n
                  ab = fnu + (i-1)
                  aa = MAX(0.5_dp, ab)
                  cw = w(i) - v(i)
                  av = ABS(v(i))
                  er = ABS(cw)
                  IF (av /= 0.0_dp) THEN
                    IF (yy == 0.0_dp) THEN
                      IF (xx > 0.0_dp) THEN
                        IF (ABS(xx) < aa) er = er / av
                      ELSE
                        IF (ABS(ffnu-0.5_dp) < 0.125_dp) THEN
                          IF (ABS(xx) < aa) er = er / av
                        ELSE
                          er = er / av
                        END IF
                      END IF
                    ELSE
                      er = er / av
                    END IF
                  END IF
                  aer(i) = er
                  IF (er > ertol) mflg = 1
                END DO
                IF (mflg /= 0) THEN
                  IF (lflg /= 1) THEN
                    WRITE (lun,5400) ertol
                    WRITE (lun,5500)
                    WRITE (lun,5600)
                    lflg = 1
                  END IF
                  kk = MAX(nz1,nz2) + 1
                  kk = MIN(n,kk)
                  WRITE (lun,5700) kode, n, ir, it, nz1, nz2, icase
                  WRITE (lun,5800) aer(1:n)
                  WRITE (lun,5800) z, fnu, w(kk), v(kk)
                END IF
              END IF
            END IF
          END DO
        END DO
      END DO loop110
    END DO
  END DO
END DO
IF (lflg == 0) WRITE (lun,5900)
STOP

5000 FORMAT (' QUICK CHECK ROUTINE FOR THE Y BESSEL FUNCTION FROM CBESY '/)
5100 FORMAT (' PARAMETERS TOL,ELIM,ALIM,RL,FNUL,DIG')
5200 FORMAT (6E12.4/)
5300 FORMAT (/' CHECKS IN THE (Z,FNU) SPACE WITH MQC = ', i2/)
5400 FORMAT (/' CASES WHICH VIOLATE THE RELATIVE ERROR TEST WITH ERTOL = ', &
             E12.4/)
5500 FORMAT (/' OUTPUT FORMAT'/' KODE,N,IR,IT,NZ1,NZ2,ICASE')
5600 FORMAT (' ER(K),K=1,N'/  &
             ' Z,FNU,W(KK),V(KK), KK=INDEX OF FIRST NON-ZERO W,V PAIR'/)
5700 FORMAT (8I5)
5800 FORMAT (7E12.4)
5900 FORMAT (/' QUICK CHECKS OK'/)


CONTAINS



SUBROUTINE cbesyh(z, fnu, kode, n, cy, nz, ierr)

! N.B. Argument CWRK has been removed.

!***BEGIN PROLOGUE  CBESYH
!***DATE WRITTEN   830501   (YYMMDD)
!***REVISION DATE  890801, 930101   (YYMMDD)
!***CATEGORY NO.  B5K
!***KEYWORDS  Y-BESSEL FUNCTION,BESSEL FUNCTION OF COMPLEX ARGUMENT,
!             BESSEL FUNCTION OF SECOND KIND
!***AUTHOR  AMOS, DONALD E., SANDIA NATIONAL LABORATORIES
!***PURPOSE  TO COMPUTE THE Y-BESSEL FUNCTION OF A COMPLEX ARGUMENT
!***DESCRIPTION

!  ON KODE=1, CBESYH COMPUTES AN N MEMBER SEQUENCE OF COMPLEX BESSEL
!  FUNCTIONS CY(I)=Y(FNU+I-1,Z) FOR REAL, NONNEGATIVE ORDERS
!  FNU+I-1, I=1,...,N AND COMPLEX Z IN THE CUT PLANE -PI < ARG(Z) <= PI.
!  ON KODE=2, CBESYH RETURNS THE SCALED FUNCTIONS

!  CY(I)=EXP(-ABS(Y))*Y(FNU+I-1,Z)   I = 1,...,N , Y=AIMAG(Z)

!  WHICH REMOVE THE EXPONENTIAL GROWTH IN BOTH THE UPPER AND
!  LOWER HALF PLANES FOR Z TO INFINITY. DEFINITIONS AND NOTATION
!  ARE FOUND IN THE NBS HANDBOOK OF MATHEMATICAL FUNCTIONS (REF. 1).

!  INPUT
!    Z      - Z=CMPLX(X,Y), Z.NE.CMPLX(0.,0.),-PI < ARG(Z) <= PI
!    FNU    - ORDER OF INITIAL Y FUNCTION, FNU >= 0.0_dp
!    KODE   - A PARAMETER TO INDICATE THE SCALING OPTION
!             KODE= 1  RETURNS
!                      CY(I)=Y(FNU+I-1,Z), I=1,...,N
!                 = 2  RETURNS
!                      CY(I)=Y(FNU+I-1,Z)*EXP(-ABS(Y)), I=1,...,N
!                      WHERE Y=AIMAG(Z)
!    N      - NUMBER OF MEMBERS OF THE SEQUENCE, N >= 1
!    CWRK   - A COMPLEX WORK VECTOR OF DIMENSION AT LEAST N

!  OUTPUT
!    CY     - A COMPLEX VECTOR WHOSE FIRST N COMPONENTS CONTAIN
!             VALUES FOR THE SEQUENCE
!             CY(I)=Y(FNU+I-1,Z)  OR
!             CY(I)=Y(FNU+I-1,Z)*EXP(-ABS(Y))  I=1,...,N
!             DEPENDING ON KODE.
!    NZ     - NZ=0 , A NORMAL RETURN
!             NZ > 0 , NZ COMPONENTS OF CY SET TO ZERO DUE TO
!             UNDERFLOW (GENERALLY ON KODE=2)
!    IERR   - ERROR FLAG
!             IERR=0, NORMAL RETURN - COMPUTATION COMPLETED
!             IERR=1, INPUT ERROR   - NO COMPUTATION
!             IERR=2, OVERFLOW      - NO COMPUTATION, FNU+N-1 IS
!                     TOO LARGE OR ABS(Z) IS TOO SMALL OR BOTH
!             IERR=3, ABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE BUT
!                     LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION PRODUCE
!                     LESS THAN HALF OF MACHINE ACCURACY
!             IERR=4, ABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTATION BECAUSE
!                     OF COMPLETE LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION
!             IERR=5, ERROR              - NO COMPUTATION,
!                     ALGORITHM TERMINATION CONDITION NOT MET

!***LONG DESCRIPTION

!    THE COMPUTATION IS CARRIED OUT BY THE FORMULA

!         Y(FNU,Z) = 0.5*(H(1,FNU,Z) - H(2,FNU,Z))/I

!    WHERE I**2 = -1 AND THE HANKEL BESSEL FUNCTIONS H(1,FNU,Z)
!    AND H(2,FNU,Z) ARE CALCULATED IN CBESH.

!    FOR NEGATIVE ORDERS,THE FORMULA

!         Y(-FNU,Z) = Y(FNU,Z)*COS(PI*FNU) + J(FNU,Z)*SIN(PI*FNU)

!    CAN BE USED. HOWEVER,FOR LARGE ORDERS CLOSE TO HALF ODD
!    INTEGERS THE FUNCTION CHANGES RADICALLY.  WHEN FNU IS A LARGE
!    POSITIVE HALF ODD INTEGER,THE MAGNITUDE OF Y(-FNU,Z)=J(FNU,Z)*
!    SIN(PI*FNU) IS A LARGE NEGATIVE POWER OF TEN.  BUT WHEN FNU IS
!    NOT A HALF ODD INTEGER, Y(FNU,Z) DOMINATES IN MAGNITUDE WITH A
!    LARGE POSITIVE POWER OF TEN AND THE MOST THAT THE SECOND TERM
!    CAN BE REDUCED IS BY UNIT ROUNDOFF FROM THE COEFFICIENT.  THUS,
!    WIDE CHANGES CAN OCCUR WITHIN UNIT ROUNDOFF OF A LARGE HALF
!    ODD INTEGER.  HERE, LARGE MEANS FNU > ABS(Z).

!    IN MOST COMPLEX VARIABLE COMPUTATION, ONE MUST EVALUATE ELEMENTARY
!    FUNCTIONS. WHEN THE MAGNITUDE OF Z OR FNU+N-1 IS LARGE, LOSSES OF
!    SIGNIFICANCE BY ARGUMENT REDUCTION OCCUR.  CONSEQUENTLY, IF EITHER ONE
!    EXCEEDS U1=SQRT(0.5/UR), THEN LOSSES EXCEEDING HALF PRECISION ARE
!    LIKELY AND AN ERROR FLAG IERR=3 IS TRIGGERED WHERE UR=R1MACH(4)=UNIT
!    ROUNDOFF.  ALSO IF EITHER IS LARGER THAN U2=0.5/UR, THEN ALL SIGNIFICANCE
!    IS LOST AND IERR=4.  IN ORDER TO USE THE INT FUNCTION, ARGUMENTS MUST BE
!    FURTHER RESTRICTED NOT TO EXCEED THE LARGEST MACHINE INTEGER,
!    U3=I1MACH(9).  THUS, THE MAGNITUDE OF Z AND FNU+N-1 IS RESTRICTED BY
!    MIN(U2,U3).  ON 32 BIT MACHINES, U1,U2, AND U3 ARE APPROXIMATELY 2.0E+3,
!    4.2E+6, 2.1E+9 IN SINGLE PRECISION ARITHMETIC AND 1.3E+8, 1.8E+16, 2.1E+9
!    IN DOUBLE PRECISION ARITHMETIC RESPECTIVELY.  THIS MAKES U2 AND U3
!    LIMITING IN THEIR RESPECTIVE ARITHMETICS. THIS MEANS THAT ONE CAN EXPECT
!    TO RETAIN, IN THE WORST CASES ON 32 BIT MACHINES, NO DIGITS IN SINGLE
!    AND ONLY 7 DIGITS IN DOUBLE PRECISION ARITHMETIC.
!    SIMILAR CONSIDERATIONS HOLD FOR OTHER MACHINES.

!    THE APPROXIMATE RELATIVE ERROR IN THE MAGNITUDE OF A COMPLEX BESSEL
!    FUNCTION CAN BE EXPRESSED BY P*10**S WHERE P=MAX(UNIT ROUNDOFF,1.0E-18)
!    IS THE NOMINAL PRECISION AND 10**S REPRESENTS THE INCREASE IN ERROR DUE
!    TO ARGUMENT REDUCTION IN THE ELEMENTARY FUNCTIONS.
!    HERE, S=MAX(1,ABS(LOG10(ABS(Z))), ABS(LOG10(FNU))) APPROXIMATELY
!    (I.E. S=MAX(1,ABS(EXPONENT OF ABS(Z),ABS(EXPONENT OF FNU)) ).
!    HOWEVER, THE PHASE ANGLE MAY HAVE ONLY ABSOLUTE ACCURACY.
!    THIS IS MOST LIKELY TO OCCUR WHEN ONE COMPONENT (IN ABSOLUTE VALUE) IS
!    LARGER THAN THE OTHER BY SEVERAL ORDERS OF MAGNITUDE.
!    IF ONE COMPONENT IS 10**K LARGER THAN THE OTHER, THEN ONE CAN EXPECT ONLY
!    MAX(ABS(LOG10(P))-K, 0) SIGNIFICANT DIGITS; OR, STATED ANOTHER WAY,
!    WHEN K EXCEEDS THE EXPONENT OF P, NO SIGNIFICANT DIGITS REMAIN IN THE
!    SMALLER COMPONENT.  HOWEVER, THE PHASE ANGLE RETAINS ABSOLUTE ACCURACY
!    BECAUSE, IN COMPLEX ARITHMETIC WITH PRECISION P, THE SMALLER COMPONENT
!    WILL NOT (AS A RULE) DECREASE BELOW P TIMES THE MAGNITUDE OF THE LARGER
!    COMPONENT. IN THESE EXTREME CASES, THE PRINCIPAL PHASE ANGLE IS ON THE
!    ORDER OF +P, -P, PI/2-P, OR -PI/2+P.

!***REFERENCES  HANDBOOK OF MATHEMATICAL FUNCTIONS BY M. ABRAMOWITZ AND
!       I. A. STEGUN, NBS AMS SERIES 55, U.S. DEPT. OF COMMERCE, 1955.

!     COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
!       BY D. E. AMOS, SAND83-0083, MAY 1983.

!     COMPUTATION OF BESSEL FUNCTIONS OF COMPLEX ARGUMENT
!       AND LARGE ORDER BY D. E. AMOS, SAND83-0643, MAY 1983

!     A SUBROUTINE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX ARGUMENT
!       AND NONNEGATIVE ORDER BY D. E. AMOS, SAND85-1018, MAY 1985

!     A PORTABLE PACKAGE FOR BESSEL FUNCTIONS OF A COMPLEX ARGUMENT
!       AND NONNEGATIVE ORDER BY D. E. AMOS, TRANS. MATH. SOFTWARE,
!       12, NO. 3, SEPTEMBER 1986, PP 265-273.

!***ROUTINES CALLED  CBESH,I1MACH,R1MACH
!***END PROLOGUE  CBESYH

COMPLEX (dp), INTENT(IN)   :: z
REAL (dp), INTENT(IN)      :: fnu
INTEGER, INTENT(IN)        :: kode
INTEGER, INTENT(IN)        :: n
COMPLEX (dp), INTENT(OUT)  :: cy(n)
INTEGER, INTENT(OUT)       :: nz
INTEGER, INTENT(OUT)       :: ierr

COMPLEX (dp)  :: c1, c2, cwrk(n), ex, hci, zu, zv
REAL (dp)     :: elim, ey, r1, r2, tay, xx, yy, ascle, rtol,  &
                 atol, aa, bb, r1m5, tol
INTEGER       :: i, k, k1, k2, nz1, nz2

!***FIRST EXECUTABLE STATEMENT  CBESYH
xx = REAL(z, KIND=dp)
yy = AIMAG(z)
ierr = 0
nz = 0
IF (xx == 0.0_dp .AND. yy == 0.0_dp) ierr = 1
IF (fnu < 0.0_dp) ierr = 1
IF (kode < 1 .OR. kode > 2) ierr = 1
IF (n < 1) ierr = 1
IF (ierr /= 0) RETURN
hci = CMPLX(0.0_dp, 0.5_dp, KIND=dp)
CALL cbesh(z, fnu, kode, 1, n, cy, nz1, ierr)
IF (ierr == 0 .OR. ierr == 3) THEN
  CALL cbesh(z, fnu, kode, 2, n, cwrk, nz2, ierr)
  IF (ierr == 0 .OR. ierr == 3) THEN
    nz = MIN(nz1, nz2)
    IF (kode /= 2) THEN
      cy(1:n) = hci * (cwrk(1:n) - cy(1:n))
      RETURN
    END IF
    r1m4 = EPSILON(0.0_dp)
    tol = MAX(r1m4, 1.0D-18)
    k1 = MINEXPONENT(0.0_dp)
    k2 = MAXEXPONENT(0.0_dp)
    r1m5 = LOG10( REAL(RADIX(0.0_dp), KIND=dp) )
    k = MIN(ABS(k1), ABS(k2))
!-----------------------------------------------------------------------
!     ELIM IS THE APPROXIMATE EXPONENTIAL UNDER- AND OVERFLOW LIMIT
!-----------------------------------------------------------------------
    elim = 2.303_dp * (k*r1m5 - 3.0_dp)
    r1 = COS(xx)
    r2 = SIN(xx)
    ex = CMPLX(r1, r2, KIND=dp)
    ey = 0.0_dp
    tay = ABS(yy+yy)
    IF (tay < elim) ey = EXP(-tay)
    IF (yy < 0.0_dp) GO TO 40
    c1 = ex * ey
    c2 = CONJG(ex)

    20 nz = 0
    rtol = 1.0_dp / tol
    ascle = TINY(0.0_dp) * rtol * 1.0E+3
    DO  i = 1, n
!       CY(I) = HCI*(C2*CWRK(I) - C1*CY(I))
      zv = cwrk(i)
      aa = REAL(zv, KIND=dp)
      bb = AIMAG(zv)
      atol = 1.0_dp
      IF (MAX(ABS(aa),ABS(bb)) <= ascle) THEN
        zv = zv * rtol
        atol = tol
      END IF
      zv = zv * c2 * hci
      zv = zv * atol
      zu = cy(i)
      aa = REAL(zu, KIND=dp)
      bb = AIMAG(zu)
      atol = 1.0_dp
      IF (MAX(ABS(aa),ABS(bb)) <= ascle) THEN
        zu = zu * rtol
        atol = tol
      END IF
      zu = zu * c1 * hci
      zu = zu * atol
      cy(i) = zv - zu
      IF (cy(i) == CMPLX(0.0_dp, 0.0_dp, KIND=dp) .AND. ey == 0.0_dp) nz = nz + 1
    END DO
    RETURN

    40 c1 = ex
    c2 = CONJG(ex) * ey
    GO TO 20
  END IF
END IF
nz = 0
RETURN
END SUBROUTINE cbesyh

END PROGRAM cqcby
