PROGRAM cqcbj

! Code converted using TO_F90 by Alan Miller
! Date: 2002-02-08  Time: 17:53:39

!***DATE WRITTEN   830501   (YYMMDD)
!***REVISION DATE  890801, 930101   (YYMMDD)

!     CQCBJ IS A QUICK CHECK ROUTINE FOR THE COMPLEX J BESSEL FUNCTION
!     GENERATED BY SUBROUTINE CBESJ.

!     CQCBJ GENERATES SEQUENCES OF J AND H BESSEL FUNCTIONS FROM CBESJ
!     AND CBESH AND CHECKS THE WRONSKIANS

!     J(FNU,Z)*H(FNU+1,1,Z)-J(FNU+1,Z)*H(FNU,1,Z)=2/(PI*I*Z)   Y.GE.0

!     J(FNU,Z)*H(FNU+1,2,Z)-J(FNU+1,Z)*H(FNU,2,Z)=-2/(PI*I*Z)  Y.LT.0

!     IN THEIR RESPECTIVE HALF PLANES.

!     THE PARAMETER MQC CAN HAVE VALUES 1 (THE DEFAULT) FOR A FASTER,
!     LESS DEFINITIVE TEST OR 2 FOR A SLOWER, MORE DEFINITIVE TEST.

!     MACHINE CONSTANTS ARE DEFINED IN FUNCTIONS I1MACH, R1MACH, AND
!     D1MACH. THESE MUST BE SELECTED BY THE USER OR SET ACCORDING TO
!     PROLOGUE INSTRUCTIONS.

USE Complex_Bessel
IMPLICIT NONE

COMPLEX (dp)  :: z, wr, cj(20), ch(20), con, t1, t2, cer
REAL (dp)     :: aa, ab, aer(20), alim, atol, dig, elim, eps, er, ertol,  &
                 fnu, fnul, gnu, hpi, pi, r, rl, rm, r1m4, r1m5, r2, t(20), &
                 tol, xnu(20), xx, yy, slak, film, st, ts, ct, sgn
INTEGER       :: i, icase, il, ir, irb, it, itl, k, kk, kode, k1, k2, lflg, &
                 m, mflg, n, np, nu, nzj, nzh, ierrj, ierrh, keps(20),  &
                 kdo(20), nl, nul
INTEGER, PARAMETER  :: mqc = 1, lun = 7

OPEN (lun, FILE='CQCBJ.OUT')
!-----------------------------------------------------------------------
!     SET PARAMETERS RELATED TO MACHINE CONSTANTS.
!     TOL IS THE APPROXIMATE UNIT ROUNDOFF LIMITED TO 1.0E-18.
!     ELIM IS THE APPROXIMATE EXPONENTIAL OVER- AND UNDERFLOW LIMIT.
!     EXP(-ELIM).LT.EXP(-ALIM)=EXP(-ELIM)/TOL    AND
!     EXP(ELIM).GT.EXP(ALIM)=EXP(ELIM)*TOL       ARE INTERVALS NEAR
!     UNDERFLOW AND OVERFLOW LIMITS WHERE SCALED ARITHMETIC IS DONE.
!     RL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC EXPANSION FOR LARGE Z.
!     DIG = NUMBER OF BASE 10 DIGITS IN TOL = 10**(-DIG).
!     FNUL IS THE LOWER BOUNDARY OF THE ASYMPTOTIC SERIES FOR LARGE FNU
!-----------------------------------------------------------------------
r1m4 = EPSILON(0.0_dp)
tol = MAX(r1m4, 1.0D-18)
aa = -LOG10(r1m4)
k1 = MINEXPONENT(0.0_dp)
k2 = MAXEXPONENT(0.0_dp)
r1m5 = LOG10( REAL(RADIX(0.0_dp), KIND=dp) )
k = MIN(ABS(k1), ABS(k2))
elim = 2.303_dp * (k*r1m5 - 3.0_dp)
ab = aa * 2.303_dp
alim = elim + MAX(-ab, -41.45_dp)
dig = MIN(aa,18.0_dp)
fnul = 10.0_dp + 6.0_dp * (dig - 3)
rl = 1.2_dp * dig + 3.0_dp
slak = 3.0_dp + 4.0_dp * (-LOG10(tol) - 7.0_dp) / 11.0_dp
slak = MAX(slak,3.0_dp)
ertol = tol * 10.0_dp ** slak
rm = 0.5_dp * (alim+elim)
rm = MIN(rm, 200.0_dp)
rm = MAX(rm, rl+10.0_dp)
r2 = MIN(fnul, rm)
!-----------------------------------------------------------------------
WRITE (lun,5000)
WRITE (lun,5100)
WRITE (lun,5200) tol, elim, alim, rl, fnul, dig
atol = 100.0_dp * tol
hpi = 2.0_dp * ATAN(1.0_dp)
pi = hpi + hpi
con = CMPLX(0.0, -1.0/hpi, KIND=dp)
WRITE (lun,5300) mqc
!-----------------------------------------------------------------------
!     TEST VALUES OF Z IN -PI.LT.ARG(Z).LE.PI
!-----------------------------------------------------------------------
!-----------------------------------------------------------------------
!     KDO(K), K=1,IL  DETERMINES WHICH OF THE IL ANGLES IN -PI TO PI
!     ARE USE TO COMPUTE VALUES OF Z
!       KDO(K) = 0  MEANS THAT THE INDEX K WILL BE USED FOR ONE OR TWO
!                   VALUES OF Z, DEPENDING ON THE CHOICE OF KEPS(K)
!              = 1  MEANS THAT THE INDEX K AND THE CORRESPONDING ANGLE
!                   WILL BE SKIPPED
!     KEPS(K), K=1,IL DETERMINES WHICH OF THE ANGLES GET INCREMENTED
!     UP AND DOWN TO PUT VALUES OF Z IN REGIONS WHERE DIFFERENT
!     FORMULAE ARE USED.
!       KEPS(K) =0  MEANS THAT THE ANGLE WILL BE USED WITHOUT CHANGE
!               =1  MEANS THAT THE ANGLE WILL BE INCREMENTED UP AND
!                   DOWN BY EPS
!     THE ANGLES TO BE USED ARE STORED IN THE T(I) ARRAY, I=1,ITL
!-----------------------------------------------------------------------
IF (mqc /= 2) THEN
  nl = 2
  il = 5
  DO  i = 1, il
    keps(i) = 0
    kdo(i) = 0
  END DO
  nul = 5
  xnu(1) = 0.0_dp
  xnu(2) = 1.0_dp
  xnu(3) = 2.0_dp
  xnu(4) = 0.5_dp * fnul
  xnu(5) = fnul + 1.1_dp
ELSE
  nl = 4
  il = 13
  DO  i = 1, il
    kdo(i) = 0
    keps(i) = 0
  END DO
  kdo(2) = 1
  kdo(6) = 1
  kdo(8) = 1
  kdo(12) = 1
  keps(3) = 1
  keps(4) = 1
  keps(5) = 1
  keps(9) = 1
  keps(10) = 1
  keps(11) = 1
  nul = 6
  xnu(1) = 0.0_dp
  xnu(2) = 0.6_dp
  xnu(3) = 1.3_dp
  xnu(4) = 2.0_dp
  xnu(5) = 0.5_dp * fnul
  xnu(6) = fnul + 1.1_dp
END IF
i = 2
eps = 0.01_dp
film = (il-1)
t(1) = -pi + eps
DO  k = 2, il
  IF (kdo(k) == 0) THEN
    t(i) = pi * (-il+2*k-1) / film
    IF (keps(k) /= 0) THEN
      ts = t(i)
      t(i) = ts - eps
      i = i + 1
      t(i) = ts + eps
    END IF
    i = i + 1
  END IF
END DO
itl = i - 1
lflg = 0
DO  kode = 1, 2
  DO  n = 1, nl
    np = n + 1
    DO  nu = 1, nul
      fnu = xnu(nu)
      gnu = fnu + (n-1) + 1.0_dp
      gnu = SQRT(gnu)
      gnu = MIN(gnu,0.5*rl)
      loop110:  DO  icase = 1, 3
        irb = MIN(2,icase)
        DO  ir = irb, 4
          SELECT CASE ( icase )
            CASE (    1)
              r = (gnu*(4-ir) + 2*(ir-1)) / 3.0_dp
            CASE (    2)
              r = (2*(4-ir) + r2*(ir-1)) / 3.0_dp
            CASE (    3)
              IF (r2 >= rm) CYCLE loop110
              r = (r2*(4-ir) + rm*(ir-1)) / 3.0_dp
          END SELECT

          DO  it = 1, itl
            ct = COS(t(it))
            st = SIN(t(it))
            IF (ABS(ct) < atol) ct = 0.0_dp
            IF (ABS(st) < atol) st = 0.0_dp
            z = CMPLX(r*ct, r*st, KIND=dp)
            xx = REAL(z, KIND=dp)
            yy = AIMAG(z)
            IF (xx /= 0.0 .OR. yy /= 0.0) THEN
              wr = con / z
              m = 1
              IF (yy < 0.0) THEN
                m = 2
                wr = -wr
              END IF
              CALL cbesj(z, fnu, kode, np, cj, nzj, ierrj)
              CALL cbesh(z, fnu, kode, m, np, ch, nzh, ierrh)
              IF (nzj == 0 .AND. nzh == 0) THEN
                IF (ierrj == 0 .AND. ierrh == 0) THEN
                  IF (kode == 2) THEN
                    sgn = 3.0 - 2.0 * (m)
                    wr = wr * CMPLX(COS(xx), -sgn*SIN(xx), KIND=dp)
                  END IF
                  kk = 0
                  mflg = 0
                  DO  i = 1, n
                    t1 = cj(i) * ch(i+1)
                    t2 = cj(i+1) * ch(i)
                    cer = t1 - t2 - wr
                    er = ABS(cer) / ABS(wr)
                    IF (er > ertol) THEN
                      IF (mflg == 0) THEN
                        mflg = 1
                        kk = i
                      END IF
                    END IF
                    aer(i) = er
                  END DO
                  IF (mflg /= 0) THEN
                    IF (lflg /= 1) THEN
                      WRITE (lun,5400) ertol
                      WRITE (lun,5500)
                      WRITE (lun,5600)
                      lflg = 1
                    END IF
                    WRITE (lun,5700) kode, n, ir, it, nzj, nzh, icase
                    WRITE (lun,5800) (aer(k),k = 1,n)
                    WRITE (lun,5800) z, fnu, cj(kk), ch(kk)
                  END IF
                END IF
              END IF
            END IF
          END DO
        END DO
      END DO loop110
    END DO
  END DO
END DO
IF (lflg == 0) WRITE (lun,5900)
STOP

5000 FORMAT (' QUICK CHECK ROUTINE FOR THE J BESSEL FUNCTION FROM CBESJ'/)
5100 FORMAT (' PARAMETERS TOL,ELIM,ALIM,RL,FNUL,DIG')
5200 FORMAT (6E12.4/)
5300 FORMAT (/' CHECKS IN THE (Z,FNU) SPACE WITH MQC = ',i2/)
5400 FORMAT (/ ' CASES WHICH VIOLATE THE RELATIVE ERROR TEST WITH ERTOL =',  &
             e12.4/)
5500 FORMAT (/' OUTPUT FORMAT'/' KODE,N,IR,IT,NZJ,NZH,ICASE')
5600 FORMAT (' ER(K),K=1,N'/  &
             ' Z,FNU,CJ(KK),CH(KK), KK=INDEX OF FIRST NON-ZERO CJ,CH PAIR'/ )
5700 FORMAT (8I5)
5800 FORMAT (9E12.4)
5900 FORMAT (/' QUICK CHECKS OK'/)
END PROGRAM cqcbj
